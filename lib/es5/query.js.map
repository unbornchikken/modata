{"version":3,"names":[],"mappings":"","sources":["query.js"],"sourcesContent":["\"use strict\";\n\nlet util = require(\"util\");\nlet _ = require(\"lodash\");\nlet InlineCountResult = require(\"./inlineCountResult\");\nlet debug = require(\"debug\")(\"modata:query\");\n\nlet parseQuery = function (query, options) {\n    let decodedQuery = {\n        q: {},\n        t: \"find\",\n        f: false,\n        s: false,\n        sk: false,\n        l: null,\n        p: false,\n        ic: false\n    };\n\n    let decode = function (value) {\n        let to = function (str) {\n            str = str.trim();\n            if ((str.length > 1) &&\n                ((str[0] === \"{\" && str[str.length - 1] === \"}\") ||\n                (str[0] === \"'\" && str[str.length - 1] === \"'\") ||\n                (str[0] === '\"' && str[str.length - 1] === '\"') ||\n                (str[0] === \"[\" && str[str.length - 1] === \"]\"))) {\n                try {\n                    return JSON.parse(str);\n                }\n                catch (e) {\n                    _.noop(e);\n                }\n            }\n            return false;\n        };\n\n        if (_.isString(value)) {\n            let result = to(value);\n            if (result === false) {\n                result = to(decodeURIComponent(value));\n            }\n            if (result === false) {\n                return value;\n            }\n            return result;\n        }\n        return value;\n    };\n\n    function walker(value, key, obj) {\n        if (!value) {\n            return;\n        }\n        if (_.isArray(value) || _.isPlainObject(value)) {\n            _.forEach(value, walker);\n        }\n        else if (_.isString(value)) {\n            if (key === \"$regex\") {\n                let m = value.match(/\\/(.*)\\//);\n                if (m) {\n                    let options;\n                    if (obj.$options) {\n                        m[2] = obj.$options;\n                        delete obj.$options;\n                    }\n                    obj[key] = new RegExp(m[1], m[2]);\n                }\n            }\n            else {\n                let decoded = decode(value);\n                if (decoded !== value) {\n                    obj[key] = decoded;\n                    walker(decoded, key, obj);\n                }\n            }\n        }\n    }\n\n    for (let key in query) {\n        if (query.hasOwnProperty(key)) {\n            switch (key) {\n                case \"q\":\n                    decodedQuery.q = decode(query[key]);\n                    _.each(decodedQuery.q, walker);\n                    break;\n                case \"t\":\n                    decodedQuery.t = query[key];\n                    break;\n                case \"f\":\n                    decodedQuery.f = decode(query[key]);\n                    break;\n                case \"s\":\n                    decodedQuery.s = decode(query[key]);\n                    break;\n                case \"sk\":\n                    decodedQuery.sk = parseInt(query[key]);\n                    break;\n                case \"l\":\n                    decodedQuery.l = parseInt(query[key]);\n                    break;\n                case \"p\":\n                    decodedQuery.p = decode(query[key]);\n                    break;\n                case \"ic\":\n                    decodedQuery.ic = (_.isString(query[key]) && query[key] === \"true\") || (_.isBoolean(query[key]) && query[key]);\n                    break;\n            }\n        }\n    }\n    return decodedQuery;\n};\n\nlet doQuery = function (query, model, options, callback) {\n    debug(\"query: %j\", query);\n    let parsedQuery = parseQuery(query, options);\n    if (!model)return parsedQuery;\n    debug(\"parsedQuery: %j\", query);\n    let mongooseQuery = model;\n    let originalQuery = model;\n\n    let canDoIC = false;\n    let aggr = false;\n\n    switch (parsedQuery.t) {\n        case \"find\":\n        case \"count\":\n        case \"distinct\":\n            canDoIC = true;\n            mongooseQuery = mongooseQuery.find(parsedQuery.q);\n            originalQuery = originalQuery.find(parsedQuery.q);\n            break;\n        case \"aggregate\":\n        case \"aggr\":\n            canDoIC = true;\n            mongooseQuery = mongooseQuery.aggregate(parsedQuery.q);\n            originalQuery = originalQuery.aggregate(parsedQuery.q);\n            aggr = true;\n            break;\n        default:\n            throw new Error(\"Not supported query type: '\" + parsedQuery.t + \"'.\");\n    }\n\n    if (!aggr) {\n        if (parsedQuery.t === \"distinct\") {\n            mongooseQuery = mongooseQuery.distinct(parsedQuery.f);\n        }\n        if (parsedQuery.s) mongooseQuery = mongooseQuery.sort(parsedQuery.s);\n        if (parsedQuery.sk) mongooseQuery = mongooseQuery.skip(parsedQuery.sk);\n        if (parsedQuery.l) mongooseQuery = mongooseQuery.limit(parsedQuery.l);\n        if (parsedQuery.f && parsedQuery.t === \"find\") mongooseQuery = mongooseQuery.select(parsedQuery.f);\n        if (parsedQuery.p) mongooseQuery = mongooseQuery.populate(parsedQuery.p);\n        if (parsedQuery.t === \"count\") {\n            mongooseQuery = mongooseQuery.count();\n        }\n    }\n    else {\n        if (parsedQuery.s) mongooseQuery = mongooseQuery.sort(parsedQuery.s);\n        if (parsedQuery.sk) mongooseQuery = mongooseQuery.skip(parsedQuery.sk);\n        if (parsedQuery.l) mongooseQuery = mongooseQuery.limit(parsedQuery.l);\n        if (parsedQuery.f) mongooseQuery = mongooseQuery.project(parsedQuery.f);\n        if (parsedQuery.p) {\n            throw new Error(\"Populate is not supported during aggregation.\");\n        }\n    }\n\n    if (parsedQuery.ic) {\n        if (!canDoIC) {\n            throw new Error(\"Inline count is not supported for query type: '\" + parsedQuery.t + \"'.\");\n        }\n        // Do inline count:\n        mongooseQuery = new InlineCountResult(originalQuery, mongooseQuery, aggr);\n    }\n\n    return mongooseQuery;\n};\n\nmodule.exports = function Query(schema, options) {\n    schema.statics.query = schema.statics.Query = function (query) {\n        options = options || {};\n        return doQuery(query, this, options);\n    };\n};\n"],"file":"query.js","sourceRoot":"/source/"}