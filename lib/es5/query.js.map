{"version":3,"names":[],"mappings":"","sources":["query.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet util = require(\"util\");\r\nlet _ = require(\"lodash\");\r\nlet InlineCountResult = require(\"./inlineCountResult\");\r\nlet debug = require(\"debug\")(\"modata:query\");\r\n\r\nlet parseQuery = function (query, options) {\r\n    let decodedQuery = {\r\n        q: {},\r\n        t: \"find\",\r\n        f: false,\r\n        s: false,\r\n        sk: false,\r\n        l: null,\r\n        p: false,\r\n        ic: false\r\n    };\r\n\r\n    let decode = function (value) {\r\n        let to = function (str) {\r\n            str = str.trim();\r\n            if ((str.length > 1) &&\r\n                ((str[0] === \"{\" && str[str.length - 1] === \"}\") ||\r\n                (str[0] === \"'\" && str[str.length - 1] === \"'\") ||\r\n                (str[0] === '\"' && str[str.length - 1] === '\"') ||\r\n                (str[0] === \"[\" && str[str.length - 1] === \"]\"))) {\r\n                try {\r\n                    return JSON.parse(str);\r\n                }\r\n                catch (e) {\r\n                    _.noop(e);\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        if (_.isString(value)) {\r\n            let result = to(value);\r\n            if (result === false) {\r\n                result = to(decodeURIComponent(value));\r\n            }\r\n            if (result === false) {\r\n                return value;\r\n            }\r\n            return result;\r\n        }\r\n        return value;\r\n    };\r\n\r\n    function walker(value, key, obj) {\r\n        if (!value) {\r\n            return;\r\n        }\r\n        if (_.isArray(value) || _.isPlainObject(value)) {\r\n            _.forEach(value, walker);\r\n        }\r\n        else if (_.isString(value)) {\r\n            if (key === \"$regex\") {\r\n                let m = value.match(/\\/(.*)\\//);\r\n                if (m) {\r\n                    let options;\r\n                    if (obj.$options) {\r\n                        m[2] = obj.$options;\r\n                        delete obj.$options;\r\n                    }\r\n                    obj[key] = new RegExp(m[1], m[2]);\r\n                }\r\n            }\r\n            else {\r\n                let decoded = decode(value);\r\n                if (decoded !== value) {\r\n                    obj[key] = decoded;\r\n                    walker(decoded, key, obj);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let key in query) {\r\n        if (query.hasOwnProperty(key)) {\r\n            switch (key) {\r\n                case \"q\":\r\n                    decodedQuery.q = decode(query[key]);\r\n                    _.each(decodedQuery.q, walker);\r\n                    break;\r\n                case \"t\":\r\n                    decodedQuery.t = query[key];\r\n                    break;\r\n                case \"f\":\r\n                    decodedQuery.f = decode(query[key]);\r\n                    break;\r\n                case \"s\":\r\n                    decodedQuery.s = decode(query[key]);\r\n                    break;\r\n                case \"sk\":\r\n                    decodedQuery.sk = parseInt(query[key]);\r\n                    break;\r\n                case \"l\":\r\n                    decodedQuery.l = parseInt(query[key]);\r\n                    break;\r\n                case \"p\":\r\n                    decodedQuery.p = decode(query[key]);\r\n                    break;\r\n                case \"ic\":\r\n                    decodedQuery.ic = (_.isString(query[key]) && query[key] === \"true\") || (_.isBoolean(query[key]) && query[key]);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return decodedQuery;\r\n};\r\n\r\nlet doQuery = function (query, model, options, callback) {\r\n    debug(\"query: %j\", query);\r\n    let parsedQuery = parseQuery(query, options);\r\n    if (!model)return parsedQuery;\r\n    debug(\"parsedQuery: %j\", query);\r\n    let mongooseQuery = model;\r\n    let originalQuery = model;\r\n\r\n    let canDoIC = false;\r\n    let aggr = false;\r\n\r\n    switch (parsedQuery.t) {\r\n        case \"find\":\r\n        case \"count\":\r\n        case \"distinct\":\r\n            canDoIC = true;\r\n            mongooseQuery = mongooseQuery.find(parsedQuery.q);\r\n            originalQuery = originalQuery.find(parsedQuery.q);\r\n            break;\r\n        case \"aggregate\":\r\n        case \"aggr\":\r\n            canDoIC = true;\r\n            mongooseQuery = mongooseQuery.aggregate(parsedQuery.q);\r\n            originalQuery = originalQuery.aggregate(parsedQuery.q);\r\n            aggr = true;\r\n            break;\r\n        default:\r\n            throw new Error(\"Not supported query type: '\" + parsedQuery.t + \"'.\");\r\n    }\r\n\r\n    if (!aggr) {\r\n        if (parsedQuery.t === \"distinct\") {\r\n            mongooseQuery = mongooseQuery.distinct(parsedQuery.f);\r\n        }\r\n        if (parsedQuery.s) mongooseQuery = mongooseQuery.sort(parsedQuery.s);\r\n        if (parsedQuery.sk) mongooseQuery = mongooseQuery.skip(parsedQuery.sk);\r\n        if (parsedQuery.l) mongooseQuery = mongooseQuery.limit(parsedQuery.l);\r\n        if (parsedQuery.f && parsedQuery.t === \"find\") mongooseQuery = mongooseQuery.select(parsedQuery.f);\r\n        if (parsedQuery.p) mongooseQuery = mongooseQuery.populate(parsedQuery.p);\r\n        if (parsedQuery.t === \"count\") {\r\n            mongooseQuery = mongooseQuery.count();\r\n        }\r\n    }\r\n    else {\r\n        if (parsedQuery.s) mongooseQuery = mongooseQuery.sort(parsedQuery.s);\r\n        if (parsedQuery.sk) mongooseQuery = mongooseQuery.skip(parsedQuery.sk);\r\n        if (parsedQuery.l) mongooseQuery = mongooseQuery.limit(parsedQuery.l);\r\n        if (parsedQuery.f) mongooseQuery = mongooseQuery.project(parsedQuery.f);\r\n        if (parsedQuery.p) {\r\n            throw new Error(\"Populate is not supported during aggregation.\");\r\n        }\r\n    }\r\n\r\n    if (parsedQuery.ic) {\r\n        if (!canDoIC) {\r\n            throw new Error(\"Inline count is not supported for query type: '\" + parsedQuery.t + \"'.\");\r\n        }\r\n        // Do inline count:\r\n        mongooseQuery = new InlineCountResult(originalQuery, mongooseQuery, aggr);\r\n    }\r\n\r\n    return mongooseQuery;\r\n};\r\n\r\nmodule.exports = function Query(schema, options) {\r\n    schema.statics.query = schema.statics.Query = function (query) {\r\n        options = options || {};\r\n        return doQuery(query, this, options);\r\n    };\r\n};\r\n"],"file":"query.js","sourceRoot":"/source/"}